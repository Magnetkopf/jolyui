{
  "name": "highlight-text",
  "type": "registry:ui",
  "dependencies": [
    "class-variance-authority"
  ],
  "files": [
    {
      "path": "ui/highlight-text.tsx",
      "content": "import { cva } from \"class-variance-authority\";\nimport * as React from \"react\";\nimport { cn } from \"@/lib/utils\";\n\nconst highlightVariants = cva(\"relative inline-block\", {\n  variants: {\n    variant: {\n      underline: \"\",\n      box: \"\",\n      circle: \"\",\n      marker: \"\",\n    },\n    color: {\n      primary:\n        \"[--highlight-color:hsl(var(--highlight-primary))] [&_path]:[stroke:var(--highlight-color)]\",\n      secondary:\n        \"[--highlight-color:hsl(var(--highlight-secondary))] [&_path]:[stroke:var(--highlight-color)]\",\n      accent:\n        \"[--highlight-color:hsl(var(--highlight-accent))] [&_path]:[stroke:var(--highlight-color)]\",\n      destructive:\n        \"[--highlight-color:hsl(var(--highlight-destructive))] [&_path]:[stroke:var(--highlight-color)]\",\n    },\n  },\n  defaultVariants: {\n    variant: \"underline\",\n    color: \"primary\",\n  },\n});\n\ntype HighlightColor = \"primary\" | \"secondary\" | \"accent\" | \"destructive\";\ntype HighlightVariant = \"underline\" | \"box\" | \"circle\" | \"marker\";\n\nexport interface HighlightTextProps\n  extends Omit<React.HTMLAttributes<HTMLSpanElement>, \"color\"> {\n  children: React.ReactNode;\n  variant?: HighlightVariant;\n  color?: HighlightColor;\n  animationDuration?: number;\n  animationDelay?: number;\n  strokeWidth?: number;\n  animate?: boolean;\n}\n\nconst HighlightText = React.forwardRef<HTMLSpanElement, HighlightTextProps>(\n  (\n    {\n      className,\n      variant = \"underline\",\n      color = \"primary\",\n      children,\n      animationDuration = 0.8,\n      animationDelay = 0,\n      strokeWidth = 2,\n      animate = true,\n      ...props\n    },\n    ref,\n  ) => {\n    const [isVisible, setIsVisible] = React.useState(!animate);\n    const [dimensions, setDimensions] = React.useState({ width: 0, height: 0 });\n    const containerRef = React.useRef<HTMLSpanElement>(null);\n\n    React.useEffect(() => {\n      const element = containerRef.current;\n      if (!element) return;\n\n      const updateDimensions = () => {\n        setDimensions({\n          width: element.offsetWidth,\n          height: element.offsetHeight,\n        });\n      };\n\n      updateDimensions();\n\n      const resizeObserver = new ResizeObserver(updateDimensions);\n      resizeObserver.observe(element);\n\n      return () => resizeObserver.disconnect();\n    }, [children]);\n\n    React.useEffect(() => {\n      if (!animate) {\n        setIsVisible(true);\n        return;\n      }\n\n      const element = containerRef.current;\n      if (!element) return;\n\n      const observer = new IntersectionObserver(\n        ([entry]) => {\n          if (entry && entry.isIntersecting) {\n            setIsVisible(true);\n            observer.disconnect();\n          }\n        },\n        { threshold: 0.5, rootMargin: \"0px 0px -50px 0px\" },\n      );\n\n      observer.observe(element);\n      return () => observer.disconnect();\n    }, [animate]);\n\n    const renderHighlight = () => {\n      const { width, height } = dimensions;\n      if (width === 0 || height === 0) return null;\n\n      const padding = 8;\n      const svgWidth = width + padding * 2;\n      const svgHeight = height + padding * 2;\n\n      const baseStyles: React.CSSProperties = {\n        position: \"absolute\",\n        top: -padding,\n        left: -padding,\n        width: svgWidth,\n        height: svgHeight,\n        pointerEvents: \"none\",\n        overflow: \"visible\",\n      };\n\n      const pathStyles: React.CSSProperties = {\n        fill: \"none\",\n        stroke: \"var(--highlight-color)\",\n        strokeWidth,\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        transition: `stroke-dashoffset ${animationDuration}s cubic-bezier(0.65, 0, 0.35, 1) ${animationDelay}s`,\n      };\n\n      switch (variant) {\n        case \"underline\": {\n          const y = svgHeight - padding + 2;\n          const pathLength = width + 10;\n          const d = `M ${padding - 2} ${y} Q ${padding + width * 0.25} ${y - 3} ${padding + width * 0.5} ${y} T ${padding + width + 2} ${y}`;\n\n          return (\n            <svg style={baseStyles} aria-hidden=\"true\">\n              <path\n                d={d}\n                style={{\n                  ...pathStyles,\n                  strokeDasharray: pathLength,\n                  strokeDashoffset: isVisible ? 0 : pathLength,\n                }}\n              />\n            </svg>\n          );\n        }\n\n        case \"box\": {\n          const boxPadding = 4;\n          const pathLength = (width + height + boxPadding * 2) * 2 + 20;\n          const d = `\n            M ${padding - boxPadding} ${padding - boxPadding + 2}\n            L ${padding + width + boxPadding} ${padding - boxPadding}\n            L ${padding + width + boxPadding + 2} ${padding + height + boxPadding}\n            L ${padding - boxPadding + 1} ${padding + height + boxPadding + 2}\n            Z\n          `;\n\n          return (\n            <svg style={baseStyles} aria-hidden=\"true\">\n              <path\n                d={d}\n                style={{\n                  ...pathStyles,\n                  strokeDasharray: pathLength,\n                  strokeDashoffset: isVisible ? 0 : pathLength,\n                }}\n              />\n            </svg>\n          );\n        }\n\n        case \"circle\": {\n          const cx = padding + width / 2;\n          const cy = padding + height / 2;\n          const rx = width / 2 + 6;\n          const ry = height / 2 + 6;\n          const pathLength = Math.PI * 2 * Math.max(rx, ry);\n\n          // Hand-drawn ellipse using bezier curves\n          const d = `\n            M ${cx - rx} ${cy}\n            C ${cx - rx} ${cy - ry * 0.55} ${cx - rx * 0.55} ${cy - ry - 2} ${cx} ${cy - ry}\n            C ${cx + rx * 0.55} ${cy - ry + 2} ${cx + rx + 1} ${cy - ry * 0.55} ${cx + rx} ${cy + 2}\n            C ${cx + rx - 1} ${cy + ry * 0.55} ${cx + rx * 0.55} ${cy + ry + 1} ${cx - 2} ${cy + ry}\n            C ${cx - rx * 0.55} ${cy + ry - 1} ${cx - rx + 2} ${cy + ry * 0.55} ${cx - rx} ${cy}\n          `;\n\n          return (\n            <svg style={baseStyles} aria-hidden=\"true\">\n              <path\n                d={d}\n                style={{\n                  ...pathStyles,\n                  strokeDasharray: pathLength,\n                  strokeDashoffset: isVisible ? 0 : pathLength,\n                }}\n              />\n            </svg>\n          );\n        }\n\n        case \"marker\": {\n          const markerHeight = height + 4;\n          const y1 = padding - 2;\n          const y2 = padding + markerHeight;\n\n          return (\n            <svg style={baseStyles} aria-hidden=\"true\">\n              <rect\n                x={padding - 2}\n                y={y1}\n                width={width + 4}\n                height={markerHeight}\n                rx={2}\n                style={{\n                  fill: \"var(--highlight-color)\",\n                  opacity: isVisible ? 0.3 : 0,\n                  transition: `opacity ${animationDuration}s cubic-bezier(0.65, 0, 0.35, 1) ${animationDelay}s`,\n                }}\n              />\n            </svg>\n          );\n        }\n\n        default:\n          return null;\n      }\n    };\n\n    return (\n      <span\n        ref={(node) => {\n          (\n            containerRef as React.MutableRefObject<HTMLSpanElement | null>\n          ).current = node;\n          if (typeof ref === \"function\") {\n            ref(node);\n          } else if (ref) {\n            ref.current = node;\n          }\n        }}\n        className={cn(highlightVariants({ variant, color, className }))}\n        {...props}\n      >\n        {renderHighlight()}\n        <span className=\"relative z-10\">{children}</span>\n      </span>\n    );\n  },\n);\n\nHighlightText.displayName = \"HighlightText\";\n\nexport { HighlightText, highlightVariants };\n",
      "type": "registry:ui",
      "target": ""
    }
  ]
}