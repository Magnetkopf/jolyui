{
  "name": "morph-text",
  "type": "registry:ui",
  "dependencies": [
    "motion"
  ],
  "files": [
    {
      "path": "ui/morph-text.tsx",
      "content": "import { cn } from \"@/lib/utils\";\nimport { AnimatePresence, motion } from \"motion/react\";\nimport * as React from \"react\";\n\ninterface MorphTextProps {\n  texts: string[];\n  className?: string;\n  morphDuration?: number;\n  cooldownDuration?: number;\n  as?: \"h1\" | \"h2\" | \"h3\" | \"h4\" | \"h5\" | \"h6\" | \"p\" | \"span\" | \"div\";\n}\n\nconst MorphText = React.forwardRef<HTMLDivElement, MorphTextProps>(\n  (\n    {\n      texts,\n      className,\n      morphDuration = 1.5,\n      cooldownDuration = 2,\n      as: Component = \"div\",\n    },\n    ref\n  ) => {\n    const [currentIndex, setCurrentIndex] = React.useState(0);\n    const [isAnimating, setIsAnimating] = React.useState(false);\n    const [displayText, setDisplayText] = React.useState(texts[0]);\n    const [morphProgress, setMorphProgress] = React.useState(0);\n\n    const currentText = texts[currentIndex];\n    const nextText = texts[(currentIndex + 1) % texts.length];\n\n    React.useEffect(() => {\n      const interval = setInterval(() => {\n        setIsAnimating(true);\n      }, (morphDuration + cooldownDuration) * 1000);\n\n      return () => clearInterval(interval);\n    }, [morphDuration, cooldownDuration]);\n\n    React.useEffect(() => {\n      if (!isAnimating) return;\n\n      let startTime: number;\n      let animationFrame: number;\n\n      const animate = (timestamp: number) => {\n        if (!startTime) startTime = timestamp;\n        const elapsed = (timestamp - startTime) / 1000;\n        const progress = Math.min(elapsed / morphDuration, 1);\n\n        setMorphProgress(progress);\n\n        // Create morphed text based on progress\n        const maxLen = Math.max(currentText.length, nextText.length);\n        let morphedText = \"\";\n\n        for (let i = 0; i < maxLen; i++) {\n          const currentChar = currentText[i] || \" \";\n          const nextChar = nextText[i] || \" \";\n\n          if (progress < 0.5) {\n            morphedText += currentChar;\n          } else {\n            morphedText += nextChar;\n          }\n        }\n\n        setDisplayText(morphedText);\n\n        if (progress < 1) {\n          animationFrame = requestAnimationFrame(animate);\n        } else {\n          setCurrentIndex((prev) => (prev + 1) % texts.length);\n          setIsAnimating(false);\n          setMorphProgress(0);\n          setDisplayText(nextText);\n        }\n      };\n\n      animationFrame = requestAnimationFrame(animate);\n\n      return () => cancelAnimationFrame(animationFrame);\n    }, [isAnimating, currentText, nextText, morphDuration, texts.length]);\n\n    // Calculate blur based on morph progress (peak blur at 0.5)\n    const blurAmount = Math.sin(morphProgress * Math.PI) * 8;\n\n    return (\n      <div ref={ref} className={cn(\"relative inline-block whitespace-nowrap\", className)}>\n        {/* Background text (current) */}\n        <motion.span\n          className=\"absolute inset-0 select-none\"\n          style={{\n            filter: `blur(${blurAmount}px)`,\n            opacity: 1 - morphProgress,\n          }}\n        >\n          {currentText.split(\"\").map((char, i) => (\n            <span\n              key={`current-${i}`}\n              className=\"inline-block\"\n              style={{\n                filter: `blur(${Math.sin(morphProgress * Math.PI) * 4}px)`,\n              }}\n            >\n              {char === \" \" ? \"\\u00A0\" : char}\n            </span>\n          ))}\n        </motion.span>\n\n        {/* Foreground text (next) */}\n        <motion.span\n          className=\"absolute inset-0 select-none\"\n          style={{\n            filter: `blur(${blurAmount}px)`,\n            opacity: morphProgress,\n          }}\n        >\n          {nextText.split(\"\").map((char, i) => (\n            <span\n              key={`next-${i}`}\n              className=\"inline-block\"\n              style={{\n                filter: `blur(${Math.sin(morphProgress * Math.PI) * 4}px)`,\n              }}\n            >\n              {char === \" \" ? \"\\u00A0\" : char}\n            </span>\n          ))}\n        </motion.span>\n\n        {/* Invisible text for layout */}\n        <span className=\"invisible\">\n          {displayText.split(\"\").map((char, i) => (\n            <span key={`layout-${i}`} className=\"inline-block\">\n              {char === \" \" ? \"\\u00A0\" : char}\n            </span>\n          ))}\n        </span>\n      </div>\n    );\n  }\n);\n\nMorphText.displayName = \"MorphText\";\n\n// Alternative: Character-by-character morph with stagger\ninterface CharacterMorphProps {\n  texts: string[];\n  className?: string;\n  interval?: number;\n  staggerDelay?: number;\n  charDuration?: number;\n}\n\nconst CharacterMorph = React.forwardRef<HTMLDivElement, CharacterMorphProps>(\n  (\n    {\n      texts,\n      className,\n      interval = 3000,\n      staggerDelay = 0.03,\n      charDuration = 0.5,\n    },\n    ref\n  ) => {\n    const [currentIndex, setCurrentIndex] = React.useState(0);\n    const currentText = texts[currentIndex];\n\n    React.useEffect(() => {\n      const timer = setInterval(() => {\n        setCurrentIndex((prev) => (prev + 1) % texts.length);\n      }, interval);\n\n      return () => clearInterval(timer);\n    }, [interval, texts.length]);\n\n    const maxLength = Math.max(...texts.map((t) => t.length));\n\n    return (\n      <div ref={ref} className={cn(\"relative inline-flex whitespace-nowrap\", className)}>\n        <AnimatePresence mode=\"popLayout\">\n          {currentText.split(\"\").map((char, i) => (\n            <motion.span\n              key={`${currentIndex}-${i}-${char}`}\n              initial={{ opacity: 0, y: 20, filter: \"blur(8px)\", rotateX: -90 }}\n              animate={{ opacity: 1, y: 0, filter: \"blur(0px)\", rotateX: 0 }}\n              exit={{ opacity: 0, y: -20, filter: \"blur(8px)\", rotateX: 90 }}\n              transition={{\n                duration: charDuration,\n                delay: i * staggerDelay,\n                ease: [0.215, 0.61, 0.355, 1],\n              }}\n              className=\"inline-block\"\n              style={{ transformStyle: \"preserve-3d\" }}\n            >\n              {char === \" \" ? \"\\u00A0\" : char}\n            </motion.span>\n          ))}\n        </AnimatePresence>\n        {/* Maintain minimum width */}\n        <span className=\"invisible absolute\">\n          {\"M\".repeat(maxLength)}\n        </span>\n      </div>\n    );\n  }\n);\n\nCharacterMorph.displayName = \"CharacterMorph\";\n\n// Scramble morph effect\ninterface ScrambleMorphProps {\n  texts: string[];\n  className?: string;\n  interval?: number;\n  scrambleDuration?: number;\n  characters?: string;\n}\n\nconst ScrambleMorph = React.forwardRef<HTMLDivElement, ScrambleMorphProps>(\n  (\n    {\n      texts,\n      className,\n      interval = 3000,\n      scrambleDuration = 1000,\n      characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*\",\n    },\n    ref\n  ) => {\n    const [currentIndex, setCurrentIndex] = React.useState(0);\n    const [displayText, setDisplayText] = React.useState(texts[0]);\n    const [isScrambling, setIsScrambling] = React.useState(false);\n\n    React.useEffect(() => {\n      const timer = setInterval(() => {\n        setIsScrambling(true);\n      }, interval);\n\n      return () => clearInterval(timer);\n    }, [interval]);\n\n    React.useEffect(() => {\n      if (!isScrambling) return;\n\n      const nextIndex = (currentIndex + 1) % texts.length;\n      const targetText = texts[nextIndex];\n      const startText = texts[currentIndex];\n      const maxLen = Math.max(startText.length, targetText.length);\n\n      let frame = 0;\n      const totalFrames = scrambleDuration / 16; // ~60fps\n      const revealFrame = totalFrames * 0.3; // Start revealing at 30%\n\n      const scramble = () => {\n        frame++;\n        const progress = frame / totalFrames;\n\n        let result = \"\";\n        for (let i = 0; i < maxLen; i++) {\n          const targetChar = targetText[i] || \"\";\n          const charRevealPoint = revealFrame + (i / maxLen) * (totalFrames - revealFrame);\n\n          if (frame >= charRevealPoint) {\n            result += targetChar;\n          } else if (frame < totalFrames * 0.1 && startText[i]) {\n            result += startText[i];\n          } else {\n            result += characters[Math.floor(Math.random() * characters.length)];\n          }\n        }\n\n        setDisplayText(result);\n\n        if (frame < totalFrames) {\n          requestAnimationFrame(scramble);\n        } else {\n          setDisplayText(targetText);\n          setCurrentIndex(nextIndex);\n          setIsScrambling(false);\n        }\n      };\n\n      requestAnimationFrame(scramble);\n    }, [isScrambling, currentIndex, texts, scrambleDuration, characters]);\n\n    return (\n      <div ref={ref} className={cn(\"inline-block font-mono whitespace-nowrap\", className)}>\n        {displayText.split(\"\").map((char, i) => (\n          <motion.span\n            key={i}\n            className=\"inline-block\"\n            animate={{\n              opacity: isScrambling ? [1, 0.7, 1] : 1,\n            }}\n            transition={{\n              duration: 0.1,\n              repeat: isScrambling ? Infinity : 0,\n            }}\n          >\n            {char === \" \" ? \"\\u00A0\" : char}\n          </motion.span>\n        ))}\n      </div>\n    );\n  }\n);\n\nScrambleMorph.displayName = \"ScrambleMorph\";\n\n// Velocity morph - quick swap with motion blur\ninterface VelocityMorphProps {\n  texts: string[];\n  className?: string;\n  interval?: number;\n}\n\nconst VelocityMorph = React.forwardRef<HTMLDivElement, VelocityMorphProps>(\n  ({ texts, className, interval = 3000 }, ref) => {\n    const [currentIndex, setCurrentIndex] = React.useState(0);\n\n    React.useEffect(() => {\n      const timer = setInterval(() => {\n        setCurrentIndex((prev) => (prev + 1) % texts.length);\n      }, interval);\n\n      return () => clearInterval(timer);\n    }, [interval, texts.length]);\n\n    return (\n      <div ref={ref} className={cn(\"relative overflow-hidden whitespace-nowrap p-2\", className)}>\n        <AnimatePresence mode=\"popLayout\">\n          <motion.div\n            key={currentIndex}\n            initial={{ \n              y: 40, \n              opacity: 0, \n              filter: \"blur(10px)\",\n              scale: 0.8,\n            }}\n            animate={{ \n              y: 0, \n              opacity: 1, \n              filter: \"blur(0px)\",\n              scale: 1,\n            }}\n            exit={{ \n              y: -40, \n              opacity: 0, \n              filter: \"blur(10px)\",\n              scale: 0.8,\n            }}\n            transition={{\n              duration: 0.4,\n              ease: [0.16, 1, 0.3, 1],\n            }}\n          >\n            {texts[currentIndex]}\n          </motion.div>\n        </AnimatePresence>\n      </div>\n    );\n  }\n);\n\nVelocityMorph.displayName = \"VelocityMorph\";\n\nexport { CharacterMorph, MorphText, ScrambleMorph, VelocityMorph };\nexport type { CharacterMorphProps, MorphTextProps, ScrambleMorphProps, VelocityMorphProps };\n\n",
      "type": "registry:ui",
      "target": ""
    }
  ]
}